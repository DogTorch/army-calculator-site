{"version":3,"file":"manualBattleSimulation-BgTIYAtC.js","sources":["../../src/services/manualBattleSimulation.ts"],"sourcesContent":["/**\n * Manual Battle Simulation Service\n * Service wrapper that adapts manual battle configurations to work with the existing battle simulation engine\n */\n\nimport { EnemyUnitBattleSimulationService, EnemyUnitBattleConfiguration } from './enemyBattleSimulation';\nimport { BattleConfiguration, BattleResult } from '../types/battleSimulation';\nimport { \n  ManualBattleConfiguration, \n  ManualBattleResult,\n  ManualBattleAnalysis,\n  ManualBattleUtils \n} from '../types/manualBattle';\nimport { ArmyComposition } from '../types/units';\nimport { EnemyUnit } from '../types/enemyUnits';\n\nexport class ManualBattleSimulationService {\n  private battleService: EnemyUnitBattleSimulationService;\n\n  constructor(unitLoader?: any) {\n    this.battleService = new EnemyUnitBattleSimulationService();\n    if (unitLoader) {\n      this.battleService.initialize(unitLoader);\n    }\n  }\n\n  /**\n   * Simulate a single manual battle configuration\n   */\n  public async simulateBattle(config: ManualBattleConfiguration): Promise<ManualBattleResult> {\n    // Validate the manual configuration\n    const playerValidation = ManualBattleUtils.validateArmyConfiguration(config.playerArmy);\n    const enemyValidation = ManualBattleUtils.validateArmyConfiguration(config.enemyArmy);\n\n    if (!playerValidation.isValid || !enemyValidation.isValid) {\n      const allErrors = [...playerValidation.errors, ...enemyValidation.errors];\n      throw new Error(`Invalid battle configuration: ${allErrors.join(', ')}`);\n    }\n\n    // Convert manual configuration to enemy unit battle configuration\n    const enemyUnitConfig = this.convertToEnemyUnitBattleConfig(config);\n\n    // Run the enemy unit battle simulation\n    const standardResult = this.battleService.simulateBattleWithEnemyUnits(enemyUnitConfig);\n\n    // Convert result back to manual battle result\n    return this.convertToManualBattleResult(standardResult, config);\n  }\n\n  /**\n   * Simulate both best and worst case scenarios for a manual battle\n   */\n  public async simulateBothScenarios(config: ManualBattleConfiguration): Promise<ManualBattleAnalysis> {\n    // Validate the manual configuration\n    const playerValidation = ManualBattleUtils.validateArmyConfiguration(config.playerArmy);\n    const enemyValidation = ManualBattleUtils.validateArmyConfiguration(config.enemyArmy);\n\n    if (!playerValidation.isValid || !enemyValidation.isValid) {\n      const allErrors = [...playerValidation.errors, ...enemyValidation.errors];\n      throw new Error(`Invalid battle configuration: ${allErrors.join(', ')}`);\n    }\n\n    // Convert to enemy unit battle configurations\n    const playerArmy = this.convertToArmyComposition(config.playerArmy, 'player');\n    const enemyUnits = this.convertToEnemyUnits(config.enemyArmy);\n\n    // Debug logging to understand what's being passed\n    console.log('üìä Manual Battle Debug - Player Army:', {\n      units: config.playerArmy.units?.length || 0,\n      stackingGroups: playerArmy.stackingOrder?.length || 0,\n      stackingDetails: playerArmy.stackingOrder?.map(g => `${g.unitName}: ${g.count} units, ${g.totalHealth} HP`)\n    });\n    console.log('üìä Manual Battle Debug - Enemy Units:', {\n      enemyUnitsCount: enemyUnits.length,\n      enemyDetails: enemyUnits.slice(0, 3).map(u => `${u.name}: ${u.health} HP, ${u.strength} STR`)\n    });\n\n    // Run both scenarios using the enemy unit battle service\n    const standardAnalysis = this.battleService.simulateBothScenariosWithEnemyUnits(\n      playerArmy, \n      enemyUnits\n    );\n\n    // Convert results to manual battle analysis\n    const bestCase = this.convertToManualBattleResult(\n      standardAnalysis.bestCase, \n      { ...config, playerGoesFirst: true }\n    );\n    \n    const worstCase = this.convertToManualBattleResult(\n      standardAnalysis.worstCase, \n      { ...config, playerGoesFirst: false }\n    );\n\n    return {\n      bestCase,\n      worstCase,\n      comparison: standardAnalysis.comparison,\n      manualConfiguration: config\n    };\n  }\n\n  /**\n   * Convert manual battle configuration to enemy unit battle configuration\n   */\n  private convertToEnemyUnitBattleConfig(config: ManualBattleConfiguration): EnemyUnitBattleConfiguration {\n    const playerArmy = this.convertToArmyComposition(config.playerArmy, 'player');\n    const enemyUnits = this.convertToEnemyUnits(config.enemyArmy);\n\n    return {\n      playerArmy,\n      enemyUnits,\n      playerGoesFirst: config.playerGoesFirst,\n      useEnemyModifiers: true\n    };\n  }\n\n  /**\n   * Convert manual enemy army to array of EnemyUnit objects\n   * Creates single enemy units with count properties instead of multiple individual units\n   */\n  private convertToEnemyUnits(enemyArmy: any): EnemyUnit[] {\n    const enemyUnits: EnemyUnit[] = [];\n    \n    console.log('üîç convertToEnemyUnits - Input enemyArmy:', {\n      hasUnits: !!enemyArmy?.units,\n      unitsLength: enemyArmy?.units?.length || 0,\n      unitsData: enemyArmy?.units?.slice(0, 2)\n    });\n    \n    if (!enemyArmy?.units || !Array.isArray(enemyArmy.units)) {\n      console.warn('‚ö†Ô∏è convertToEnemyUnits - No valid units array in enemyArmy');\n      return enemyUnits;\n    }\n    \n    for (const armyUnit of enemyArmy.units) {\n      const unit = armyUnit.unit;\n      \n      if (armyUnit.isInfinite) {\n        // Infinite units don't have a count (immortal)\n        enemyUnits.push({\n          name: unit.name,\n          unit_types: unit.unit_types,\n          health: unit.health,\n          strength: unit.strength,\n          attack_modifiers: unit.attack_modifiers || [],\n          isMortal: false\n        });\n      } else {\n        // Finite units have a specific count (mortal)\n        enemyUnits.push({\n          name: unit.name,\n          unit_types: unit.unit_types,\n          health: unit.health,\n          strength: unit.strength,\n          attack_modifiers: unit.attack_modifiers || [],\n          count: armyUnit.quantity,\n          isMortal: true\n        });\n      }\n    }\n    \n    return enemyUnits;\n  }\n\n  /**\n   * Convert manual army configuration to standard army composition\n   */\n  private convertToArmyComposition(army: any, side: 'player' | 'enemy'): ArmyComposition {\n    const stackingGroups = ManualBattleUtils.convertToStackingGroups(army);\n    \n    // Calculate totals\n    let totalStrength = 0;\n    let totalHealth = 0;\n    let totalLeadershipCost = 0;\n    let totalDominanceCost = 0;\n    let totalMercenaryCount = 0;\n    const unitsMap: Record<string, number> = {};\n\n    for (const armyUnit of army.units) {\n      const quantity = armyUnit.isInfinite ? 999999 : armyUnit.quantity;\n      const unit = armyUnit.unit;\n      \n      unitsMap[unit.name] = quantity;\n      totalStrength += quantity * unit.strength;\n      totalHealth += quantity * unit.health;\n      totalLeadershipCost += quantity * (unit.leadership_cost || unit.leadershipCost || 0);\n      totalDominanceCost += quantity * (unit.dominance_cost || unit.dominanceCost || 0);\n      \n      if (unit.cost_type === 'Mercenary' || unit.class === 'Mercenary') {\n        totalMercenaryCount += quantity;\n      }\n    }\n\n    return {\n      units: unitsMap,\n      totalStrength,\n      totalHealth,\n      totalLeadershipCost,\n      totalDominanceCost,\n      totalMercenaryCount,\n      stackingOrder: stackingGroups,\n      isValidStacking: this.validateStacking(stackingGroups),\n      efficiencyScore: totalStrength / Math.max(totalLeadershipCost + totalDominanceCost, 1)\n    };\n  }\n\n\n  /**\n   * Validate stacking order (weakest to strongest by total health)\n   */\n  private validateStacking(stackingGroups: any[]): boolean {\n    if (stackingGroups.length <= 1) return true;\n    \n    for (let i = 1; i < stackingGroups.length; i++) {\n      if (stackingGroups[i - 1].totalHealth > stackingGroups[i].totalHealth) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Convert standard battle result to manual battle result\n   */\n  private convertToManualBattleResult(\n    standardResult: BattleResult, \n    config: ManualBattleConfiguration\n  ): ManualBattleResult {\n    return {\n      ...standardResult,\n      manualConfiguration: config,\n      enemySurvivors: this.calculateEnemySurvivors(config.enemyArmy, standardResult)\n    };\n  }\n\n  /**\n   * Calculate which enemy units survived (relevant for infinite units)\n   * In the standard battle system, enemies never actually die, so infinite units always \"survive\"\n   */\n  private calculateEnemySurvivors(enemyArmy: any, battleResult: BattleResult): any[] {\n    return enemyArmy.units.map((armyUnit: any) => ({\n      ...armyUnit,\n      // Infinite units always survive, finite units might be \"damaged\" but not eliminated in our system\n      quantity: armyUnit.isInfinite ? armyUnit.quantity : armyUnit.quantity,\n      survived: true\n    }));\n  }\n\n  /**\n   * Get battle performance metrics for manual battles\n   */\n  public getBattleMetrics(analysis: ManualBattleAnalysis): any {\n    const { bestCase, worstCase, comparison } = analysis;\n    \n    return {\n      efficiency: {\n        bestCaseEfficiency: bestCase.totalDamageDealtToEnemies / bestCase.battleDuration,\n        worstCaseEfficiency: worstCase.totalDamageDealtToEnemies / worstCase.battleDuration,\n        averageEfficiency: comparison.averageDamage / ((bestCase.battleDuration + worstCase.battleDuration) / 2)\n      },\n      consistency: {\n        damageVariability: Math.abs(comparison.damageDifference) / comparison.averageDamage,\n        survivalVariability: Math.abs(comparison.survivalDifference) / comparison.averageSurvival,\n        overallConsistency: 1 - (Math.abs(comparison.damageDifference) + Math.abs(comparison.survivalDifference)) / \n                           (comparison.averageDamage + comparison.averageSurvival)\n      },\n      playerArmyStats: this.getArmyStats(analysis.manualConfiguration.playerArmy),\n      enemyArmyStats: this.getArmyStats(analysis.manualConfiguration.enemyArmy)\n    };\n  }\n\n  /**\n   * Get statistical information about an army configuration\n   */\n  private getArmyStats(army: any): any {\n    let totalUnits = 0;\n    let totalStrength = 0;\n    let totalHealth = 0;\n    let infiniteUnitTypes = 0;\n    let unitTypeCount = army.units.length;\n    \n    const unitTypeBreakdown: Record<string, any> = {};\n\n    for (const armyUnit of army.units) {\n      const unit = armyUnit.unit;\n      const quantity = armyUnit.isInfinite ? 999999 : armyUnit.quantity;\n      \n      if (armyUnit.isInfinite) {\n        infiniteUnitTypes++;\n      }\n      \n      totalUnits += quantity;\n      totalStrength += quantity * unit.strength;\n      totalHealth += quantity * unit.health;\n      \n      // Track unit types\n      for (const unitType of unit.unit_types) {\n        if (!unitTypeBreakdown[unitType]) {\n          unitTypeBreakdown[unitType] = { count: 0, strength: 0, health: 0 };\n        }\n        unitTypeBreakdown[unitType].count += quantity;\n        unitTypeBreakdown[unitType].strength += quantity * unit.strength;\n        unitTypeBreakdown[unitType].health += quantity * unit.health;\n      }\n    }\n\n    return {\n      totalUnits,\n      totalStrength,\n      totalHealth,\n      averageStrengthPerUnit: totalUnits > 0 ? totalStrength / totalUnits : 0,\n      averageHealthPerUnit: totalUnits > 0 ? totalHealth / totalUnits : 0,\n      unitTypeCount,\n      infiniteUnitTypes,\n      hasInfiniteUnits: infiniteUnitTypes > 0,\n      unitTypeBreakdown,\n      strengthToHealthRatio: totalHealth > 0 ? totalStrength / totalHealth : 0\n    };\n  }\n\n  /**\n   * Validate that a manual battle configuration can be simulated\n   */\n  public validateConfiguration(config: ManualBattleConfiguration): { isValid: boolean; errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Validate player army\n    const playerValidation = ManualBattleUtils.validateArmyConfiguration(config.playerArmy);\n    errors.push(...playerValidation.errors);\n    warnings.push(...playerValidation.warnings);\n\n    // Validate enemy army\n    const enemyValidation = ManualBattleUtils.validateArmyConfiguration(config.enemyArmy);\n    errors.push(...enemyValidation.errors);\n    warnings.push(...enemyValidation.warnings);\n\n    // Check for simulation performance concerns\n    const enemyGroupCount = this.calculateEnemyGroupCount(config.enemyArmy);\n    const playerUnitCount = config.playerArmy.units.reduce((sum, u) => sum + (u.isInfinite ? 0 : u.quantity), 0);\n    \n    if (enemyGroupCount > 50 && playerUnitCount < 10) {\n      warnings.push('Large enemy army vs small player army may result in very short battle');\n    }\n    \n    if (enemyGroupCount > 80) {\n      warnings.push('Very large enemy army may affect simulation performance');\n    }\n\n    // Check for infinite unit balance\n    const infiniteEnemyTypes = config.enemyArmy.units.filter(u => u.isInfinite).length;\n    if (infiniteEnemyTypes > 5) {\n      warnings.push('Many infinite enemy unit types may make battle analysis less meaningful');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n}"],"names":["ManualBattleSimulationService","unitLoader","__publicField","EnemyUnitBattleSimulationService","config","playerValidation","ManualBattleUtils","enemyValidation","allErrors","enemyUnitConfig","standardResult","playerArmy","enemyUnits","_a","_b","_c","g","u","standardAnalysis","bestCase","worstCase","enemyArmy","armyUnit","unit","army","side","stackingGroups","totalStrength","totalHealth","totalLeadershipCost","totalDominanceCost","totalMercenaryCount","unitsMap","quantity","i","battleResult","analysis","comparison","totalUnits","infiniteUnitTypes","unitTypeCount","unitTypeBreakdown","unitType","errors","warnings","enemyGroupCount","playerUnitCount","sum"],"mappings":"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"}